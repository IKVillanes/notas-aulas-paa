
#PAA
#Professor Fabrício

### Single Source Shortest Paths

Revisão do single source shortest path:

Unweighted graph:
 - BFS - O(V+E)

Non-negative edge weights:
 - Dijkstra - O(V log(V)+E) using Fibbonaci Heap

Negative edge weights:
 - Bellman Ford - O(V E)

### All-Pairs Shortest Paths

Find for each pair the shortest path.

Por exemplo para encontrar o grau de separação máximo entre pessoas
no twitter.

Uma abordagem possível: Run single-source SP algorithm |V| times.

1° Nonnegative Edges: Use Dijkstra
- Time complexity:
 - O(V³)
 - O(VE lg V) with binary heap
 - O(V² lg V + VE) with Fibonacci heap

2° Negative Edges: Use Bellman-Ford
- Time complexity: O(V²+E) = O(V^4^)
(Em grafos com arestas negativas é possível melhorar o desempenho)

3° Use Dynamic Programming:
  (The 3 algorithms in this chapter are dynamic)
  
  - "Repeated Squaring": O(V³ log(V))
  - Floyd-Warshall: O(V³)
  - Johnson's: O( V² log(V) + VE )
  
### Repeated Squaring Algorithm

Esse algoritmo calcula todas as distancias com número de arestas
`m` antes de calcular todas as distâncias de comprimento `m+1`. A
parte dinâmica do algoritmo utiliza as distância com `m` arestas
para calcular as distâncias com `m+1` arestas dessa forma melhorando
a performance.

Seja o grafo dado em uma matrix de adjacencia com Wij sendo o peso de cada aresta i,j:

```
W = (Wij)
```

Seja Dij(m) = peso do caminho mínimo entre dois vertices i,j contendo no máximo `m` arestas.

```
Dij = { 0 if i=j
      { infinito, caso contrário

Dij(m) = min (Dij(m-1), min { Dik(m-1) + Wkj})

or

Dij(m) = min <= k <= n { Dik (m-1) + Wjk}, since Wjj=0.
```

O algoritmo funciona realizando operações sobre a matriz W repetidamente.

Começando com a matriz `DM[1] = W`, repita o calculo de distâncias para todos
os vertices com caminhos de `m` onde `DM[m] = (Dij(m), para todo ij)`

```python
def repeatedSquare(W):
  # Número de vertices:
  n = len(W)
  
  DM[1] = W

  for m from 2 to n-1:
    DM[m] = extend(D[m-1], W)
  
  return DM[n-1]

def extend(DM, W):
  # Número de vertices:
	n = len(W)

  # Matriz extendida:
  extDM = [][]
  
  # Para todo i,j inclusive com i=j:
  for i from 1 to n:
    for j from 1 to n:

      # Calcule o menor caminho entre os dois com uma aresta a mais:
      extDM[i][j] = infinito
      for k from 1 to n:
        if( extDM[i][j] > DM[i][k] + W[k][j])
          extDM[i][j] = DM[i][k] + W[k][j]
```
Complexidade no tempo: O(V^4^)

Note a semelhança do método `extend` com uma multiplicação de matrizes
onde para cada i,j da matriz final é preciso iterar por uma linha
de uma matriz A e uma coluna de uma matriz B, no caso do extend A=DM e B=W.

A única diferença é o calculo realizado que não é uma multiplicação mas sim um mínimo.

**Otimizações:**

O algoritmo pode ser otimizado de duas formas:

1. O tempo de execução pode ser melhorado para O(V^3^ log(V))
   se voce calcular as matrizes em potencias de 2, daí o nome
   "Repeated Squaring":

   - DM[2] = extend(W, W)
   - DM[4] = extend(DM[2], DM[2])
   - DM[8] = extend(DM[4], DM[4])
   - ...
   - DM[m] = extend(DM[m/2], DM[m/2])

2. Pode-se otimizar o algoritmo para utilizar apenas duas matrizes
   de forma que a complexidade no expaço seja apenas O(V²)

### SSSP and Matrix-Vector Multiplication:

Este algoritmo se parece muito com o Repeated Squaring.
Mas guarda os dados em uma matriz.

A execução desse algoritmo é feita sobre um matriz e a cada etapa
se parece muito com uma multiplicação de matrizes.

Se W é a matriz de distancia de uma aresta entre todos os pares de nós.

A matriz de distancia D(i) onde i é a profundidade, pode ser dado por:

  D(i) = D(i-1) W (como uma multiplicação de matrizes)

Tem uma otimização para esse algoritmo, mas não consegui copiar.

### Floyd-Warshall Algorithm

*Esse é o algoritmo mais importante segundo o professor*

* Também é um algoritmo dinamico.
* dij(k) = weight of SP from vertex i to vertex j with all intermediate vertices in the set { 1,2, ..., k }

dij(k) = { wij if k=0
         { min(dij(k-1), dik(k-1) + dkj(k-1) if k>=1

```
n = rows[D];
D(0) = W;
for k=1 to n do:
  for i=1 to n do:
    for j=1 to n do:
      dij(k) = min(dij(k-1), dik(k-1)+ dkj(k-1))
return D(n)

```

Nesse algoritmo voce inclui um a um cada vertice do grafo.
E calcula para todos os caminhos se compensa passar por esse
vertice é para chegar a cada outro vertice.

### Johnson's Algorithm

Idéia: Repondere as arestas de forma que:

- Não haja arestas de peso negativo.
- Shortest paths are preserved (A shortest path in the original graph is still one in the new reweighted graph)

An obvius attemp: subtract the minimum weight from all the edge weights. E.g. if the minimum weight is -2:
* -2 - -2 = 0
*  3 - -2 = 5

Esssa abordagem funciona? Não, o caminho minímo não é preservado.

Johnson's Insight:

Add a vertex s to the original graph G, with edges of weight 0 to each vertx in G:

Assign new weights w to each edge as follow:

  A continha não consegui anotar, mas é só uma linha.
  O professor disse que a conta é simples mas provar que esse método preserva os caminhos minímos é complexo.

  // A conta parece ser o seguinte:
  PesoAresta = PesoAresta + CustoParaChegar ao no de origem - custo para chegar ao nó de destino.

Algoritmo crie um novo nó S que se liga a todos os demais nós por uma aresta de peso 0.

Aplique Bellman-Ford com raiz em S.

Voce vai encontrar apenas os caminhos de peso negativo.

Agora voce tem um peso para se chegar em qualquer aresta do grafo que pode ser 0 ou menor.

Aplique:
  PesoAresta = PesoAresta + CustoParaChegar ao no de origem - custo para chegar ao nó de destino.

Para cada aresta.

Assim temos o novo grafo reponderado de forma a preservar os caminhos minimos.

---

Summary:

Dinamic programming algorithm: O(V^4)
Connection to matrix-multiplication:
 - Improved Version (repeated squaring): O(V³ logV)
 - Floyd-Warshal

---

### Os slides devem estar disponíveis no moodle em breve

---

#Fim da Aula





