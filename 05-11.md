
#PAA
#Professor Fabrício

### Single Source Shortest Paths

Revisão do single source shortest path:

Unweighted graph:
 - BFS - O(V+E)

Non-negative edge weights:
 - Dijkstra - O(V log(V)+E) using Fibbonaci Heap

Negative edge weights:
 - Bellman Ford - O(V E)

### All-Pairs Shortest Paths

Find for each pair the shortest path.

Por exemplo para encontrar o grau de separação máximo entre pessoas
no twitter.

Uma abordagem possível: Run single-source SP algorithm |V| times.

1° Nonnegative Edges: Use Dijkstra
- Time complexity:
 - O(V³)
 - O(VE lg V) with binary heap
 - O(V² lg V + VE) with Fibonacci heap

2° Negative Edges: Use Bellman-Ford
- Time complexity: O(V²+E) = O(V^4^)
(Em grafos com arestas negativas é possível melhorar o desempenho)

3° Use Dynamic Programming:
  (The 3 algorithms in this chapter are dynamic)
  
  - "Repeated Squaring": O(V³ log(V))
  - Floyd-Warshall: O(V³)
  - Johnson's: O( V² log(V) + VE )
  
### Repeated Squaring Algorithm

Esse algoritmo calcula todas as distancias com número de arestas
`m` antes de calcular todas as distâncias de comprimento `m+1`. A
parte dinâmica do algoritmo utiliza as distância com `m` arestas
para calcular as distâncias com `m+1` arestas dessa forma melhorando
a performance.

Seja o grafo dado em uma matrix de adjacencia com Wij sendo o peso de cada aresta i,j:

```
W = (Wij)
```

Seja Dij(m) = peso do caminho mínimo entre dois vertices i,j contendo no máximo `m` arestas.

```
Dij = { 0 if i=j
      { infinito, caso contrário

Dij(m) = min (Dij(m-1), min { Dik(m-1) + Wkj})

or

Dij(m) = min <= k <= n { Dik (m-1) + Wjk}, since Wjj=0.
```

O algoritmo funciona realizando operações sobre a matriz W repetidamente.

Começando com a matriz `MD[1] = W`, repita o calculo de distâncias para todos
os vertices com caminhos de `m` onde `MD[m] = (Dij(m), para todo ij)`

```python
def repeatedSquare(W):
  # Número de vertices:
  n = len(W)
  
  MD[1] = W

  for m from 2 to n-1:
    MD[m] = extend(D[m-1], W)
  
  return MD[n-1]

def extend(MD, W):
  # Número de vertices:
	n = len(W)

  # Matriz extendida:
  extMD = [][]
  
  # Para todo i,j inclusive com i=j:
  for i from 1 to n:
    for j from 1 to n:

      # Calcule o menor caminho entre os dois com uma aresta a mais:
      extMD[i][j] = infinito
      for k from 1 to n:
        if( extMD[i][j] > MD[i][k] + W[k][j])
          extMD[i][j] = MD[i][k] + W[k][j]
```
Complexidade no tempo: O(V^4^)

Note a semelhança do método `extend` com uma multiplicação de matrizes
onde para cada i,j da matriz final é preciso iterar por uma linha
de uma matriz A e uma coluna de uma matriz B, no caso do extend A=MD e B=W.

A única diferença é o calculo realizado que não é uma multiplicação mas sim um mínimo.

**Otimizações:**

O algoritmo pode ser otimizado de duas formas:

1. O tempo de execução pode ser melhorado para O(V^3^ log(V))
   se voce calcular as matrizes em potencias de 2, daí o nome
   "Repeated Squaring":

   - MD[2] = extend(W, W)
   - MD[4] = extend(MD[2], MD[2])
   - MD[8] = extend(MD[4], MD[4])
   - ...
   - MD[m] = extend(MD[m/2], MD[m/2])

2. Pode-se otimizar o algoritmo para utilizar apenas duas matrizes
   de forma que a complexidade no expaço seja apenas O(V²)

### Floyd-Warshall Algorithm

*Esse é o algoritmo mais importante segundo o professor*

Este algoritmo também é dinâmico mas funciona de forma diferente.

A matriz `MD[0] = W`, assim como no algoritmo anterior, porém para
cada iteração o que será feito é adicionar um vértice como candidato
a vertice intermédiário para formar um caminho.

Dessa forma `MD[k] = (Dij(k) para todo i,j)`, e `Dij(k)` = peso do caminho mínimo entre vertices `i,j`
onde os vertices intermediarios do caminho se restrigem aos vertices: `1..k`

Ou seja cada iteração corresponde à inserção de um novo vertice
e na verificação de todos os caminhos que poderiam lucrar em passar por esse vertice.

O objetivo do algoritmo é encontrar `MD[n]`, ou seja o conjunto de todos os melhores caminhos
com todos os vertices do grafo incluidos.

A equação de recursividade do algoritmo pode ser dada por:

```
Dij(k) = { Wij if k=0
         { min(Dij(k-1), Dik(k-1) + Dkj(k-1) if k>=1
```

O pseudocódigo do algoritmo é simples em comparação com o outro método:

```
def floydWarshall(W): 
  n = len(W);
  MD[0] = W;
  
  # For each inserted node:
  for k from 1 to n:
    # For each other pair of nodes on the graph:
    for i from 1 to n:
      for j from 1 to n:
        # If the path thru the new node is faster than the old path:
        if MD[k][i][j] > MD[k-1][i][k] + MD[k-1][k][j]:
          # Set the new path as the best path found:
          MD[k][i][j] = MD[k-1][i][k] + MD[k-1][k][j]
  
  return MD[n]
```

Complexidade no tempo: O(V³)

O algoritmo pode ser melhorado para utilizar apenas duas matrizes mantendo
a complexidade no espaço em O(V²), o que é desejável.

O algoritmo também pode ser modificado para retornar a matriz de precedessores junto
com a resposta permitindo recuperar os caminhos mínimos e não apenas as distancias mínimas.

### Johnson's Algorithm

Idéia: Repondere as arestas de forma que:

- Não haja arestas de peso negativo.
- Shortest paths are preserved (A shortest path in the original graph is still one in the new reweighted graph)

An obvius attemp: subtract the minimum weight from all the edge weights. E.g. if the minimum weight is -2:
* -2 - -2 = 0
*  3 - -2 = 5

Esssa abordagem funciona? Não, o caminho minímo não é preservado.

Johnson's Insight:

Add a vertex s to the original graph G, with edges of weight 0 to each vertx in G:

Assign new weights w to each edge as follow:

  A continha não consegui anotar, mas é só uma linha.
  O professor disse que a conta é simples mas provar que esse método preserva os caminhos minímos é complexo.

  // A conta parece ser o seguinte:
  PesoAresta = PesoAresta + CustoParaChegar ao no de origem - custo para chegar ao nó de destino.

Algoritmo crie um novo nó S que se liga a todos os demais nós por uma aresta de peso 0.

Aplique Bellman-Ford com raiz em S.

Voce vai encontrar apenas os caminhos de peso negativo.

Agora voce tem um peso para se chegar em qualquer aresta do grafo que pode ser 0 ou menor.

Aplique:
  PesoAresta = PesoAresta + CustoParaChegar ao no de origem - custo para chegar ao nó de destino.

Para cada aresta.

Assim temos o novo grafo reponderado de forma a preservar os caminhos minimos.

---

Summary:

Dinamic programming algorithm: O(V^4)
Connection to matrix-multiplication:
 - Improved Version (repeated squaring): O(V³ logV)
 - Floyd-Warshal

---

### Os slides devem estar disponíveis no moodle em breve

---

#Fim da Aula





